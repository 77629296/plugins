"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.findFirstDecoratorByName = exports.removeDecoratorByName = exports.createGenericArray = exports.statement = exports.expression = exports.typedStatement = exports.typedExpression = exports.expressionStatement = exports.logicalExpression = exports.awaitExpression = exports.memberExpression = exports.callExpression = exports.importDeclaration = exports.getNamedProperties = exports.getClassMethodById = exports.getMethods = exports.addIdentifierToConstructorSuperCall = exports.findConstructor = exports.isConstructor = exports.importContainedIdentifiers = exports.deleteClassMemberByKey = exports.getClassDeclarationById = exports.findContainedIdentifiers = exports.classProperty = exports.classDeclaration = exports.exportNames = exports.addImports = exports.importNames = exports.addAutoGenerationComment = exports.removeESLintComments = exports.removeTSInterfaceDeclares = exports.removeTSClassDeclares = exports.removeTSVariableDeclares = exports.removeImportsTSIgnoreComments = exports.removeTSIgnoreComments = exports.transformTemplateLiteralToStringLiteral = exports.evaluateJSX = exports.interpolate = exports.getExportedNames = exports.extractImportDeclarations = exports.partialParse = exports.parse = exports.ParseError = void 0;
const recast = __importStar(require("recast"));
const ast_types_1 = require("ast-types");
const lodash_1 = require("lodash");
const parser = __importStar(require("./parser"));
const partialParser = __importStar(require("./partial-parser"));
const TS_IGNORE_TEXT = "@ts-ignore";
const CONSTRUCTOR_NAME = "constructor";
const ARRAY_ID = ast_types_1.builders.identifier("Array");
const STATIC_COMMENT = `
------------------------------------------------------------------------------ 
This code was generated by Amplication. 
 
Changes to this file will be lost if the code is regenerated. 

There are other ways to to customize your code, see this doc to learn more
https://docs.amplication.com/docs/how-to/custom-code

------------------------------------------------------------------------------
  `;
class ParseError extends SyntaxError {
    constructor(message, source) {
        super(`${message}\nSource:\n${source}`);
    }
}
exports.ParseError = ParseError;
function parse(source, options) {
    try {
        return recast.parse(source, Object.assign(Object.assign({}, options), { parser }));
    }
    catch (error) {
        if (error instanceof SyntaxError) {
            throw new ParseError(error.message, source);
        }
        throw error;
    }
}
exports.parse = parse;
function partialParse(source, options) {
    try {
        return recast.parse(source, Object.assign(Object.assign({}, options), { tolerant: true, parser: partialParser }));
    }
    catch (error) {
        if (error instanceof SyntaxError) {
            throw new ParseError(error.message, source);
        }
        throw error;
    }
}
exports.partialParse = partialParse;
function consolidateImports(declarations) {
    const moduleToDeclarations = (0, lodash_1.groupBy)(declarations, (declaration) => declaration.source.value);
    const moduleToDeclaration = (0, lodash_1.mapValues)(moduleToDeclarations, (declarations, module) => {
        const specifiers = (0, lodash_1.uniqBy)(declarations.flatMap((declaration) => declaration.specifiers || []), (specifier) => {
            if (ast_types_1.namedTypes.ImportSpecifier.check(specifier)) {
                return specifier.imported.name;
            }
            return specifier.type;
        });
        return ast_types_1.builders.importDeclaration(specifiers, ast_types_1.builders.stringLiteral(module));
    });
    return Object.values(moduleToDeclaration);
}
function extractImportDeclarations(file) {
    const newBody = [];
    const imports = [];
    for (const statement of file.program.body) {
        if (ast_types_1.namedTypes.ImportDeclaration.check(statement)) {
            imports.push(statement);
        }
        else {
            newBody.push(statement);
        }
    }
    file.program.body = newBody;
    return imports;
}
exports.extractImportDeclarations = extractImportDeclarations;
function getExportedNames(code) {
    const file = parse(code);
    const ids = [];
    for (const node of file.program.body) {
        if (ast_types_1.namedTypes.ExportNamedDeclaration.check(node)) {
            if (!node.declaration) {
                throw new Error("Not implemented");
            }
            if ("id" in node.declaration &&
                node.declaration.id &&
                "name" in node.declaration.id) {
                ids.push(node.declaration.id);
            }
            else if ("declarations" in node.declaration) {
                for (const declaration of node.declaration.declarations) {
                    if ("id" in declaration &&
                        declaration.id &&
                        "name" in declaration.id) {
                        ids.push(declaration.id);
                    }
                    else {
                        throw new Error("Not implemented");
                    }
                }
            }
            else {
                throw new Error("Not implemented");
            }
        }
    }
    return ids;
}
exports.getExportedNames = getExportedNames;
function interpolate(ast, mapping) {
    return recast.visit(ast, {
        visitIdentifier(path) {
            const { name } = path.node;
            if (mapping.hasOwnProperty(name)) {
                const replacement = mapping[name];
                path.replace(replacement);
            }
            this.traverse(path);
        },
        visitClassDeclaration(path) {
            const childPath = path.get("decorators");
            if (childPath.value) {
                this.traverse(childPath);
            }
            return this.traverse(path);
        },
        visitClassProperty(path) {
            const childPath = path.get("decorators");
            if (childPath.value) {
                this.traverse(childPath);
            }
            this.traverse(path);
        },
        visitCallExpression(path) {
            const childPath = path.get("typeParameters");
            if (childPath.value) {
                this.traverse(childPath);
            }
            this.traverse(path);
        },
        visitTemplateLiteral(path) {
            const canTransformToStringLiteral = path.node.expressions.every((expression) => ast_types_1.namedTypes.Identifier.check(expression) &&
                expression.name in mapping &&
                ast_types_1.namedTypes.StringLiteral.check(mapping[expression.name]));
            if (canTransformToStringLiteral) {
                path.node.expressions = path.node.expressions.map((expression) => {
                    const identifier = expression;
                    return mapping[identifier.name];
                });
                path.replace(transformTemplateLiteralToStringLiteral(path.node));
            }
            this.traverse(path);
        },
        visitJSXElement(path) {
            evaluateJSX(path, mapping);
            this.traverse(path);
        },
        visitJSXFragment(path) {
            evaluateJSX(path, mapping);
            this.traverse(path);
        },
    });
}
exports.interpolate = interpolate;
function evaluateJSX(path, mapping) {
    const childrenPath = path.get("children");
    childrenPath.each((childPath) => {
        const { node } = childPath;
        if (ast_types_1.namedTypes.JSXExpressionContainer.check(node) &&
            ast_types_1.namedTypes.Identifier.check(node.expression)) {
            const { expression } = node;
            const mapped = mapping[expression.name];
            if (ast_types_1.namedTypes.JSXElement.check(mapped)) {
                childPath.replace(mapped);
            }
            else if (ast_types_1.namedTypes.StringLiteral.check(mapped)) {
                childPath.replace(ast_types_1.builders.jsxText(mapped.value));
            }
            else if (ast_types_1.namedTypes.JSXFragment.check(mapped) && mapped.children) {
                childPath.replace(...mapped.children);
            }
        }
    });
}
exports.evaluateJSX = evaluateJSX;
function transformTemplateLiteralToStringLiteral(templateLiteral) {
    const value = templateLiteral.quasis
        .map((quasie, i) => {
        const expression = templateLiteral.expressions[i];
        if (expression) {
            return quasie.value.raw + expression.value;
        }
        return quasie.value.raw;
    })
        .join("");
    return ast_types_1.builders.stringLiteral(value);
}
exports.transformTemplateLiteralToStringLiteral = transformTemplateLiteralToStringLiteral;
function removeTSIgnoreComments(ast) {
    recast.visit(ast, {
        visitComment(path) {
            if (path.value.value.includes(TS_IGNORE_TEXT)) {
                path.prune();
            }
            this.traverse(path);
        },
    });
}
exports.removeTSIgnoreComments = removeTSIgnoreComments;
function removeImportsTSIgnoreComments(file) {
    for (const statement of file.program.body) {
        if (!ast_types_1.namedTypes.ImportDeclaration.check(statement)) {
            break;
        }
        removeTSIgnoreComments(statement);
    }
}
exports.removeImportsTSIgnoreComments = removeImportsTSIgnoreComments;
function removeTSVariableDeclares(ast) {
    recast.visit(ast, {
        visitVariableDeclaration(path) {
            if (path.get("declare").value) {
                path.prune();
            }
            this.traverse(path);
        },
    });
}
exports.removeTSVariableDeclares = removeTSVariableDeclares;
function removeTSClassDeclares(ast) {
    recast.visit(ast, {
        visitClassDeclaration(path) {
            if (path.get("declare").value) {
                path.prune();
            }
            this.traverse(path);
        },
    });
}
exports.removeTSClassDeclares = removeTSClassDeclares;
function removeTSInterfaceDeclares(ast) {
    recast.visit(ast, {
        visitTSInterfaceDeclaration(path) {
            if (path.get("declare").value) {
                path.prune();
            }
            this.traverse(path);
        },
    });
}
exports.removeTSInterfaceDeclares = removeTSInterfaceDeclares;
function removeESLintComments(ast) {
    recast.visit(ast, {
        visitComment(path) {
            const comment = path.value;
            if (comment.value.match(/^\s+eslint-disable/)) {
                path.prune();
            }
            this.traverse(path);
        },
    });
}
exports.removeESLintComments = removeESLintComments;
function addAutoGenerationComment(file) {
    const autoGen = ast_types_1.builders.commentBlock(STATIC_COMMENT, true);
    if (!file.comments) {
        file.comments = [];
    }
    file.comments.unshift(autoGen);
}
exports.addAutoGenerationComment = addAutoGenerationComment;
function importNames(names, source) {
    return ast_types_1.builders.importDeclaration(names.map((name) => ast_types_1.builders.importSpecifier(name)), ast_types_1.builders.stringLiteral(source));
}
exports.importNames = importNames;
function addImports(file, imports) {
    const existingImports = extractImportDeclarations(file);
    const consolidatedImports = consolidateImports([
        ...existingImports,
        ...imports,
    ]);
    file.program.body.unshift(...consolidatedImports);
}
exports.addImports = addImports;
function exportNames(names) {
    return ast_types_1.builders.exportNamedDeclaration(null, names.map((name) => ast_types_1.builders.exportSpecifier.from({
        exported: name,
        id: name,
        name,
    })));
}
exports.exportNames = exportNames;
function classDeclaration(id, body, superClass = null, decorators = []) {
    const declaration = ast_types_1.builders.classDeclaration(id, body, superClass);
    if (!decorators.length) {
        return declaration;
    }
    const code = [
        ...decorators.map((decorator) => recast.print(decorator).code),
        recast.print(declaration).code,
    ].join("\n");
    const ast = parse(code);
    const [classDeclaration] = ast.program.body;
    return classDeclaration;
}
exports.classDeclaration = classDeclaration;
function classProperty(key, typeAnnotation, definitive = false, optional = false, defaultValue = null, decorators = []) {
    if (optional && definitive) {
        throw new Error("Must either provide definitive: true, optional: true or none of them");
    }
    const code = `class A {
    ${decorators.map((decorator) => recast.print(decorator).code).join("\n")}
    ${recast.print(key).code}${definitive ? "!" : ""}${optional ? "?" : ""}${recast.print(typeAnnotation).code}${defaultValue ? `= ${recast.print(defaultValue).code}` : ""}
  
  }`;
    const ast = parse(code);
    const [classDeclaration] = ast.program.body;
    const [property] = classDeclaration.body.body;
    return property;
}
exports.classProperty = classProperty;
function findContainedIdentifiers(node, identifiers) {
    const nameToIdentifier = Object.fromEntries(Array.from(identifiers, (identifier) => [identifier.name, identifier]));
    const contained = [];
    recast.visit(node, {
        visitIdentifier(path) {
            if (nameToIdentifier.hasOwnProperty(path.node.name)) {
                contained.push(path.node);
            }
            this.traverse(path);
        },
        visitClassDeclaration(path) {
            const childPath = path.get("decorators");
            if (childPath.value) {
                this.traverse(childPath);
            }
            return this.traverse(path);
        },
        visitClassProperty(path) {
            const childPath = path.get("decorators");
            if (childPath.value) {
                this.traverse(childPath);
            }
            this.traverse(path);
        },
    });
    return contained;
}
exports.findContainedIdentifiers = findContainedIdentifiers;
function getClassDeclarationById(node, id) {
    let classDeclaration = null;
    recast.visit(node, {
        visitClassDeclaration(path) {
            if (path.node.id && path.node.id.name === id.name) {
                classDeclaration = path.node;
                return false;
            }
            return this.traverse(path);
        },
    });
    if (!classDeclaration) {
        throw new Error(`Could not find class declaration with the identifier ${id.name} in provided AST node`);
    }
    return classDeclaration;
}
exports.getClassDeclarationById = getClassDeclarationById;
function deleteClassMemberByKey(declaration, id) {
    for (const [index, member] of declaration.body.body.entries()) {
        if (member &&
            "key" in member &&
            ast_types_1.namedTypes.Identifier.check(member.key) &&
            member.key.name === id.name) {
            delete declaration.body.body[index];
            break;
        }
    }
}
exports.deleteClassMemberByKey = deleteClassMemberByKey;
function importContainedIdentifiers(node, moduleToIdentifiers) {
    const idToModule = new Map(Object.entries(moduleToIdentifiers).flatMap(([key, values]) => values.map((value) => [value, key])));
    const nameToId = Object.fromEntries(Array.from(idToModule.keys(), (identifier) => [identifier.name, identifier]));
    const containedIds = findContainedIdentifiers(node, idToModule.keys());
    const moduleToContainedIds = (0, lodash_1.groupBy)(containedIds, (id) => {
        const knownId = nameToId[id.name];
        const module = idToModule.get(knownId);
        return module;
    });
    return Object.entries(moduleToContainedIds).map(([module, containedIds]) => importNames(containedIds, module));
}
exports.importContainedIdentifiers = importContainedIdentifiers;
function isConstructor(method) {
    return (ast_types_1.namedTypes.Identifier.check(method.key) &&
        method.key.name === CONSTRUCTOR_NAME);
}
exports.isConstructor = isConstructor;
function findConstructor(classDeclaration) {
    return classDeclaration.body.body.find((member) => ast_types_1.namedTypes.ClassMethod.check(member) && isConstructor(member));
}
exports.findConstructor = findConstructor;
function addIdentifierToConstructorSuperCall(ast, identifier) {
    recast.visit(ast, {
        visitClassMethod(path) {
            const classMethodNode = path.node;
            if (isConstructor(classMethodNode)) {
                recast.visit(classMethodNode, {
                    visitCallExpression(path) {
                        const callExpressionNode = path.node;
                        if (callExpressionNode.callee.type === "Super") {
                            callExpressionNode.arguments.push(identifier);
                        }
                        this.traverse(path);
                    },
                });
            }
            this.traverse(path);
        },
    });
}
exports.addIdentifierToConstructorSuperCall = addIdentifierToConstructorSuperCall;
function getMethods(classDeclaration) {
    return classDeclaration.body.body.filter((member) => ast_types_1.namedTypes.ClassMethod.check(member) && !isConstructor(member));
}
exports.getMethods = getMethods;
function getClassMethodById(classDeclaration, methodId) {
    const allMethodWithoutConstructor = getMethods(classDeclaration);
    return (allMethodWithoutConstructor.find((method) => method.key === methodId) ||
        null);
}
exports.getClassMethodById = getClassMethodById;
function getNamedProperties(declaration) {
    return declaration.body.body.filter((member) => ast_types_1.namedTypes.ClassProperty.check(member) &&
        ast_types_1.namedTypes.Identifier.check(member.key));
}
exports.getNamedProperties = getNamedProperties;
exports.importDeclaration = typedStatement(ast_types_1.namedTypes.ImportDeclaration);
exports.callExpression = typedExpression(ast_types_1.namedTypes.CallExpression);
exports.memberExpression = typedExpression(ast_types_1.namedTypes.MemberExpression);
exports.awaitExpression = typedExpression(ast_types_1.namedTypes.AwaitExpression);
exports.logicalExpression = typedExpression(ast_types_1.namedTypes.LogicalExpression);
exports.expressionStatement = typedStatement(ast_types_1.namedTypes.ExpressionStatement);
function typedExpression(type) {
    return (strings, ...values) => {
        const exp = expression(strings, ...values);
        if (!type.check(exp)) {
            throw new Error(`Code must define a single ${type} at the top level`);
        }
        return exp;
    };
}
exports.typedExpression = typedExpression;
function typedStatement(type) {
    return (strings, ...values) => {
        const exp = statement(strings, ...values);
        if (!type.check(exp)) {
            throw new Error(`Code must define a single ${type} at the top level`);
        }
        return exp;
    };
}
exports.typedStatement = typedStatement;
function expression(strings, ...values) {
    const stat = statement(strings, ...values);
    if (!ast_types_1.namedTypes.ExpressionStatement.check(stat)) {
        throw new Error("Code must define a single statement expression at the top level");
    }
    return stat.expression;
}
exports.expression = expression;
function statement(strings, ...values) {
    const code = codeTemplate(strings, ...values);
    const file = partialParse(code);
    if (file.program.body.length !== 1) {
        throw new Error("Code must have exactly one statement");
    }
    const [firstStatement] = file.program.body;
    return firstStatement;
}
exports.statement = statement;
function codeTemplate(strings, ...values) {
    return strings
        .flatMap((string, i) => {
        const value = values[i];
        if (typeof value === "string")
            return [string, value];
        return [
            string,
            Array.isArray(value)
                ? value.map((item) => recast.print(item).code).join("")
                : recast.print(value).code,
        ];
    })
        .join("");
}
function createGenericArray(itemType) {
    return ast_types_1.builders.tsTypeReference(ARRAY_ID, ast_types_1.builders.tsTypeParameterInstantiation([itemType]));
}
exports.createGenericArray = createGenericArray;
function removeDecoratorByName(node, decoratorName) {
    let decorator = null;
    recast.visit(node, {
        visitDecorator(path) {
            var _a;
            const callee = path.get("expression", "callee");
            if (callee.value && ((_a = callee.value.property) === null || _a === void 0 ? void 0 : _a.name) === decoratorName) {
                decorator = path.value;
                path.prune();
            }
            return this.traverse(path);
        },
        visitClassDeclaration(path) {
            const childPath = path.get("decorators");
            if (childPath.value) {
                this.traverse(childPath);
            }
            return this.traverse(path);
        },
        visitClassProperty(path) {
            const childPath = path.get("decorators");
            if (childPath.value) {
                this.traverse(childPath);
            }
            this.traverse(path);
        },
    });
    if (!decorator) {
        return false;
    }
    return true;
}
exports.removeDecoratorByName = removeDecoratorByName;
function findFirstDecoratorByName(node, decoratorName) {
    let decorator = null;
    recast.visit(node, {
        visitDecorator(path) {
            const callee = path.get("expression", "callee");
            if (callee.value && callee.value.name === decoratorName) {
                decorator = path.value;
                return false;
            }
            return this.traverse(path);
        },
        visitClassDeclaration(path) {
            const childPath = path.get("decorators");
            if (childPath.value) {
                this.traverse(childPath);
            }
            return this.traverse(path);
        },
        visitClassProperty(path) {
            const childPath = path.get("decorators");
            if (childPath.value) {
                this.traverse(childPath);
            }
            this.traverse(path);
        },
    });
    if (!decorator) {
        throw new Error(`Could not find class decorator with the name ${decoratorName} in provided AST node`);
    }
    return decorator;
}
exports.findFirstDecoratorByName = findFirstDecoratorByName;
//# sourceMappingURL=astUtil.js.map